import {
  Color4,
  DrawWrapper,
  EngineStore,
  InternalTexture,
  InternalTextureSource,
  Logger,
  Material,
  Observable,
  SceneComponentConstants,
  ShaderStore,
  Texture,
  ThinEngine,
  Vector2,
  VertexBuffer,
  __esm,
  init_buffer,
  init_drawWrapper,
  init_engineStore,
  init_helperFunctions,
  init_internalTexture,
  init_logger,
  init_material,
  init_math_color,
  init_math_vector,
  init_observable,
  init_sceneComponent,
  init_shaderStore,
  init_texture,
  init_thinEngine
} from "./chunk-K2ZNLUVQ.js";

// node_modules/@babylonjs/core/Engines/Extensions/engine.dynamicTexture.js
var init_engine_dynamicTexture = __esm({
  "node_modules/@babylonjs/core/Engines/Extensions/engine.dynamicTexture.js"() {
    init_thinEngine();
    init_internalTexture();
    ThinEngine.prototype.createDynamicTexture = function(width, height, generateMipMaps, samplingMode) {
      const texture = new InternalTexture(this, InternalTextureSource.Dynamic);
      texture.baseWidth = width;
      texture.baseHeight = height;
      if (generateMipMaps) {
        width = this.needPOTTextures ? ThinEngine.GetExponentOfTwo(width, this._caps.maxTextureSize) : width;
        height = this.needPOTTextures ? ThinEngine.GetExponentOfTwo(height, this._caps.maxTextureSize) : height;
      }
      texture.width = width;
      texture.height = height;
      texture.isReady = false;
      texture.generateMipMaps = generateMipMaps;
      texture.samplingMode = samplingMode;
      this.updateTextureSamplingMode(samplingMode, texture);
      this._internalTexturesCache.push(texture);
      return texture;
    };
    ThinEngine.prototype.updateDynamicTexture = function(texture, source, invertY, premulAlpha = false, format, forceBindTexture = false, allowGPUOptimization = false) {
      if (!texture) {
        return;
      }
      const gl = this._gl;
      const target = gl.TEXTURE_2D;
      const wasPreviouslyBound = this._bindTextureDirectly(target, texture, true, forceBindTexture);
      this._unpackFlipY(invertY === void 0 ? texture.invertY : invertY);
      if (premulAlpha) {
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);
      }
      const textureType = this._getWebGLTextureType(texture.type);
      const glformat = this._getInternalFormat(format ? format : texture.format);
      const internalFormat = this._getRGBABufferInternalSizedFormat(texture.type, glformat);
      gl.texImage2D(target, 0, internalFormat, glformat, textureType, source);
      if (texture.generateMipMaps) {
        gl.generateMipmap(target);
      }
      if (!wasPreviouslyBound) {
        this._bindTextureDirectly(target, null);
      }
      if (premulAlpha) {
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
      }
      texture.isReady = true;
    };
  }
});

// node_modules/@babylonjs/core/Materials/Textures/dynamicTexture.js
var DynamicTexture;
var init_dynamicTexture = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/dynamicTexture.js"() {
    init_logger();
    init_texture();
    init_engine_dynamicTexture();
    DynamicTexture = class _DynamicTexture extends Texture {
      /**
       * Creates a DynamicTexture
       * @param name defines the name of the texture
       * @param options provides 3 alternatives for width and height of texture, a canvas, object with width and height properties, number for both width and height
       * @param scene defines the scene where you want the texture
       * @param generateMipMaps defines the use of MinMaps or not (default is false)
       * @param samplingMode defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)
       * @param format defines the texture format to use (default is Engine.TEXTUREFORMAT_RGBA)
       * @param invertY defines if the texture needs to be inverted on the y axis during loading
       */
      constructor(name3, options, scene = null, generateMipMaps = false, samplingMode = 3, format = 5, invertY) {
        super(null, scene, !generateMipMaps, invertY, samplingMode, void 0, void 0, void 0, void 0, format);
        this.name = name3;
        this.wrapU = Texture.CLAMP_ADDRESSMODE;
        this.wrapV = Texture.CLAMP_ADDRESSMODE;
        this._generateMipMaps = generateMipMaps;
        const engine = this._getEngine();
        if (!engine) {
          return;
        }
        if (options.getContext) {
          this._canvas = options;
          this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);
        } else {
          this._canvas = engine.createCanvas(1, 1);
          if (options.width || options.width === 0) {
            this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);
          } else {
            this._texture = engine.createDynamicTexture(options, options, generateMipMaps, samplingMode);
          }
        }
        const textureSize = this.getSize();
        if (this._canvas.width !== textureSize.width) {
          this._canvas.width = textureSize.width;
        }
        if (this._canvas.height !== textureSize.height) {
          this._canvas.height = textureSize.height;
        }
        this._context = this._canvas.getContext("2d");
      }
      /**
       * Get the current class name of the texture useful for serialization or dynamic coding.
       * @returns "DynamicTexture"
       */
      getClassName() {
        return "DynamicTexture";
      }
      /**
       * Gets the current state of canRescale
       */
      get canRescale() {
        return true;
      }
      _recreate(textureSize) {
        this._canvas.width = textureSize.width;
        this._canvas.height = textureSize.height;
        this.releaseInternalTexture();
        this._texture = this._getEngine().createDynamicTexture(textureSize.width, textureSize.height, this._generateMipMaps, this.samplingMode);
      }
      /**
       * Scales the texture
       * @param ratio the scale factor to apply to both width and height
       */
      scale(ratio) {
        const textureSize = this.getSize();
        textureSize.width *= ratio;
        textureSize.height *= ratio;
        this._recreate(textureSize);
      }
      /**
       * Resizes the texture
       * @param width the new width
       * @param height the new height
       */
      scaleTo(width, height) {
        const textureSize = this.getSize();
        textureSize.width = width;
        textureSize.height = height;
        this._recreate(textureSize);
      }
      /**
       * Gets the context of the canvas used by the texture
       * @returns the canvas context of the dynamic texture
       */
      getContext() {
        return this._context;
      }
      /**
       * Clears the texture
       */
      clear() {
        const size = this.getSize();
        this._context.fillRect(0, 0, size.width, size.height);
      }
      /**
       * Updates the texture
       * @param invertY defines the direction for the Y axis (default is true - y increases downwards)
       * @param premulAlpha defines if alpha is stored as premultiplied (default is false)
       * @param allowGPUOptimization true to allow some specific GPU optimizations (subject to engine feature "allowGPUOptimizationsForGUI" being true)
       */
      update(invertY, premulAlpha = false, allowGPUOptimization = false) {
        this._getEngine().updateDynamicTexture(this._texture, this._canvas, invertY === void 0 ? true : invertY, premulAlpha, this._format || void 0, void 0, allowGPUOptimization);
      }
      /**
       * Draws text onto the texture
       * @param text defines the text to be drawn
       * @param x defines the placement of the text from the left
       * @param y defines the placement of the text from the top when invertY is true and from the bottom when false
       * @param font defines the font to be used with font-style, font-size, font-name
       * @param color defines the color used for the text
       * @param clearColor defines the color for the canvas, use null to not overwrite canvas
       * @param invertY defines the direction for the Y axis (default is true - y increases downwards)
       * @param update defines whether texture is immediately update (default is true)
       */
      drawText(text, x, y, font, color, clearColor, invertY, update = true) {
        const size = this.getSize();
        if (clearColor) {
          this._context.fillStyle = clearColor;
          this._context.fillRect(0, 0, size.width, size.height);
        }
        this._context.font = font;
        if (x === null || x === void 0) {
          const textSize = this._context.measureText(text);
          x = (size.width - textSize.width) / 2;
        }
        if (y === null || y === void 0) {
          const fontSize = parseInt(font.replace(/\D/g, ""));
          y = size.height / 2 + fontSize / 3.65;
        }
        this._context.fillStyle = color || "";
        this._context.fillText(text, x, y);
        if (update) {
          this.update(invertY);
        }
      }
      /**
       * Clones the texture
       * @returns the clone of the texture.
       */
      clone() {
        const scene = this.getScene();
        if (!scene) {
          return this;
        }
        const textureSize = this.getSize();
        const newTexture = new _DynamicTexture(this.name, textureSize, scene, this._generateMipMaps);
        newTexture.hasAlpha = this.hasAlpha;
        newTexture.level = this.level;
        newTexture.wrapU = this.wrapU;
        newTexture.wrapV = this.wrapV;
        return newTexture;
      }
      /**
       * Serializes the dynamic texture.  The scene should be ready before the dynamic texture is serialized
       * @returns a serialized dynamic texture object
       */
      serialize() {
        const scene = this.getScene();
        if (scene && !scene.isReady()) {
          Logger.Warn("The scene must be ready before serializing the dynamic texture");
        }
        const serializationObject = super.serialize();
        if (_DynamicTexture._IsCanvasElement(this._canvas)) {
          serializationObject.base64String = this._canvas.toDataURL();
        }
        serializationObject.invertY = this._invertY;
        serializationObject.samplingMode = this.samplingMode;
        return serializationObject;
      }
      static _IsCanvasElement(canvas) {
        return canvas.toDataURL !== void 0;
      }
      /** @internal */
      _rebuild() {
        this.update();
      }
    };
  }
});

// node_modules/@babylonjs/core/Events/clipboardEvents.js
var ClipboardEventTypes, ClipboardInfo;
var init_clipboardEvents = __esm({
  "node_modules/@babylonjs/core/Events/clipboardEvents.js"() {
    ClipboardEventTypes = class {
    };
    ClipboardEventTypes.COPY = 1;
    ClipboardEventTypes.CUT = 2;
    ClipboardEventTypes.PASTE = 3;
    ClipboardInfo = class {
      /**
       *Creates an instance of ClipboardInfo.
       * @param type Defines the type of event (BABYLON.ClipboardEventTypes)
       * @param event Defines the related dom event
       */
      constructor(type, event) {
        this.type = type;
        this.event = event;
      }
      /**
       *  Get the clipboard event's type from the keycode.
       * @param keyCode Defines the keyCode for the current keyboard event.
       * @returns {number}
       */
      static GetTypeFromCharacter(keyCode) {
        const charCode = keyCode;
        switch (charCode) {
          case 67:
            return ClipboardEventTypes.COPY;
          case 86:
            return ClipboardEventTypes.PASTE;
          case 88:
            return ClipboardEventTypes.CUT;
          default:
            return -1;
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Layers/layerSceneComponent.js
var LayerSceneComponent;
var init_layerSceneComponent = __esm({
  "node_modules/@babylonjs/core/Layers/layerSceneComponent.js"() {
    init_sceneComponent();
    init_engineStore();
    LayerSceneComponent = class {
      /**
       * Creates a new instance of the component for the given scene
       * @param scene Defines the scene to register the component in
       */
      constructor(scene) {
        this.name = SceneComponentConstants.NAME_LAYER;
        this.scene = scene || EngineStore.LastCreatedScene;
        if (!this.scene) {
          return;
        }
        this._engine = this.scene.getEngine();
        this.scene.layers = new Array();
      }
      /**
       * Registers the component in a given scene
       */
      register() {
        this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_LAYER, this, this._drawCameraBackground);
        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_LAYER, this, this._drawCameraForegroundWithPostProcessing);
        this.scene._afterCameraPostProcessStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERAPOSTPROCESS_LAYER, this, this._drawCameraForegroundWithoutPostProcessing);
        this.scene._beforeRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_LAYER, this, this._drawRenderTargetBackground);
        this.scene._afterRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERTARGETDRAW_LAYER, this, this._drawRenderTargetForegroundWithPostProcessing);
        this.scene._afterRenderTargetPostProcessStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERTARGETPOSTPROCESS_LAYER, this, this._drawRenderTargetForegroundWithoutPostProcessing);
      }
      /**
       * Rebuilds the elements related to this component in case of
       * context lost for instance.
       */
      rebuild() {
        const layers = this.scene.layers;
        for (const layer of layers) {
          layer._rebuild();
        }
      }
      /**
       * Disposes the component and the associated resources.
       */
      dispose() {
        const layers = this.scene.layers;
        while (layers.length) {
          layers[0].dispose();
        }
      }
      _draw(predicate) {
        const layers = this.scene.layers;
        if (layers.length) {
          this._engine.setDepthBuffer(false);
          for (const layer of layers) {
            if (predicate(layer)) {
              layer.render();
            }
          }
          this._engine.setDepthBuffer(true);
        }
      }
      _drawCameraPredicate(layer, isBackground, applyPostProcess, cameraLayerMask) {
        return !layer.renderOnlyInRenderTargetTextures && layer.isBackground === isBackground && layer.applyPostProcess === applyPostProcess && (layer.layerMask & cameraLayerMask) !== 0;
      }
      _drawCameraBackground(camera) {
        this._draw((layer) => {
          return this._drawCameraPredicate(layer, true, true, camera.layerMask);
        });
      }
      _drawCameraForegroundWithPostProcessing(camera) {
        this._draw((layer) => {
          return this._drawCameraPredicate(layer, false, true, camera.layerMask);
        });
      }
      _drawCameraForegroundWithoutPostProcessing(camera) {
        this._draw((layer) => {
          return this._drawCameraPredicate(layer, false, false, camera.layerMask);
        });
      }
      _drawRenderTargetPredicate(layer, isBackground, applyPostProcess, cameraLayerMask, renderTargetTexture) {
        return layer.renderTargetTextures.length > 0 && layer.isBackground === isBackground && layer.applyPostProcess === applyPostProcess && layer.renderTargetTextures.indexOf(renderTargetTexture) > -1 && (layer.layerMask & cameraLayerMask) !== 0;
      }
      _drawRenderTargetBackground(renderTarget) {
        this._draw((layer) => {
          return this._drawRenderTargetPredicate(layer, true, true, this.scene.activeCamera.layerMask, renderTarget);
        });
      }
      _drawRenderTargetForegroundWithPostProcessing(renderTarget) {
        this._draw((layer) => {
          return this._drawRenderTargetPredicate(layer, false, true, this.scene.activeCamera.layerMask, renderTarget);
        });
      }
      _drawRenderTargetForegroundWithoutPostProcessing(renderTarget) {
        this._draw((layer) => {
          return this._drawRenderTargetPredicate(layer, false, false, this.scene.activeCamera.layerMask, renderTarget);
        });
      }
      /**
       * Adds all the elements from the container to the scene
       * @param container the container holding the elements
       */
      addFromContainer(container) {
        if (!container.layers) {
          return;
        }
        container.layers.forEach((layer) => {
          this.scene.layers.push(layer);
        });
      }
      /**
       * Removes all the elements in the container from the scene
       * @param container contains the elements to remove
       * @param dispose if the removed element should be disposed (default: false)
       */
      removeFromContainer(container, dispose = false) {
        if (!container.layers) {
          return;
        }
        container.layers.forEach((layer) => {
          const index = this.scene.layers.indexOf(layer);
          if (index !== -1) {
            this.scene.layers.splice(index, 1);
          }
          if (dispose) {
            layer.dispose();
          }
        });
      }
    };
  }
});

// node_modules/@babylonjs/core/Shaders/layer.fragment.js
var name, shader;
var init_layer_fragment = __esm({
  "node_modules/@babylonjs/core/Shaders/layer.fragment.js"() {
    init_shaderStore();
    init_helperFunctions();
    name = "layerPixelShader";
    shader = `varying vec2 vUV;
uniform sampler2D textureSampler;
uniform vec4 color;
#include<helperFunctions>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
vec4 baseColor=texture2D(textureSampler,vUV);
#ifdef LINEAR
baseColor.rgb=toGammaSpace(baseColor.rgb);
#endif
#ifdef ALPHATEST
if (baseColor.a<0.4)
discard;
#endif
gl_FragColor=baseColor*color;
#define CUSTOM_FRAGMENT_MAIN_END
}`;
    ShaderStore.ShadersStore[name] = shader;
  }
});

// node_modules/@babylonjs/core/Shaders/layer.vertex.js
var name2, shader2;
var init_layer_vertex = __esm({
  "node_modules/@babylonjs/core/Shaders/layer.vertex.js"() {
    init_shaderStore();
    name2 = "layerVertexShader";
    shader2 = `attribute vec2 position;
uniform vec2 scale;
uniform vec2 offset;
uniform mat4 textureMatrix;
varying vec2 vUV;
const vec2 madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vec2 shiftedPosition=position*scale+offset;
vUV=vec2(textureMatrix*vec4(shiftedPosition*madd+madd,1.0,0.0));
gl_Position=vec4(shiftedPosition,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;
    ShaderStore.ShadersStore[name2] = shader2;
  }
});

// node_modules/@babylonjs/core/Layers/layer.js
var Layer;
var init_layer = __esm({
  "node_modules/@babylonjs/core/Layers/layer.js"() {
    init_observable();
    init_math_vector();
    init_math_color();
    init_engineStore();
    init_buffer();
    init_material();
    init_texture();
    init_sceneComponent();
    init_layerSceneComponent();
    init_drawWrapper();
    init_layer_fragment();
    init_layer_vertex();
    Layer = class {
      /**
       * Determines if the layer is drawn before (true) or after (false) post-processing.
       * If the layer is background, it is always before.
       */
      set applyPostProcess(value) {
        this._applyPostProcess = value;
      }
      get applyPostProcess() {
        return this.isBackground || this._applyPostProcess;
      }
      /**
       * Back compatibility with callback before the onDisposeObservable existed.
       * The set callback will be triggered when the layer has been disposed.
       */
      set onDispose(callback) {
        if (this._onDisposeObserver) {
          this.onDisposeObservable.remove(this._onDisposeObserver);
        }
        this._onDisposeObserver = this.onDisposeObservable.add(callback);
      }
      /**
       * Back compatibility with callback before the onBeforeRenderObservable existed.
       * The set callback will be triggered just before rendering the layer.
       */
      set onBeforeRender(callback) {
        if (this._onBeforeRenderObserver) {
          this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
        }
        this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);
      }
      /**
       * Back compatibility with callback before the onAfterRenderObservable existed.
       * The set callback will be triggered just after rendering the layer.
       */
      set onAfterRender(callback) {
        if (this._onAfterRenderObserver) {
          this.onAfterRenderObservable.remove(this._onAfterRenderObserver);
        }
        this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);
      }
      /**
       * Instantiates a new layer.
       * This represents a full screen 2d layer.
       * This can be useful to display a picture in the  background of your scene for instance.
       * @see https://www.babylonjs-playground.com/#08A2BS#1
       * @param name Define the name of the layer in the scene
       * @param imgUrl Define the url of the texture to display in the layer
       * @param scene Define the scene the layer belongs to
       * @param isBackground Defines whether the layer is displayed in front or behind the scene
       * @param color Defines a color for the layer
       */
      constructor(name3, imgUrl, scene, isBackground, color) {
        this.name = name3;
        this._applyPostProcess = true;
        this.scale = new Vector2(1, 1);
        this.offset = new Vector2(0, 0);
        this.alphaBlendingMode = 2;
        this.layerMask = 268435455;
        this.renderTargetTextures = [];
        this.renderOnlyInRenderTargetTextures = false;
        this.isEnabled = true;
        this._vertexBuffers = {};
        this.onDisposeObservable = new Observable();
        this.onBeforeRenderObservable = new Observable();
        this.onAfterRenderObservable = new Observable();
        this.texture = imgUrl ? new Texture(imgUrl, scene, true) : null;
        this.isBackground = isBackground === void 0 ? true : isBackground;
        this.color = color === void 0 ? new Color4(1, 1, 1, 1) : color;
        this._scene = scene || EngineStore.LastCreatedScene;
        let layerComponent = this._scene._getComponent(SceneComponentConstants.NAME_LAYER);
        if (!layerComponent) {
          layerComponent = new LayerSceneComponent(this._scene);
          this._scene._addComponent(layerComponent);
        }
        this._scene.layers.push(this);
        const engine = this._scene.getEngine();
        this._drawWrapper = new DrawWrapper(engine);
        const vertices = [];
        vertices.push(1, 1);
        vertices.push(-1, 1);
        vertices.push(-1, -1);
        vertices.push(1, -1);
        const vertexBuffer = new VertexBuffer(engine, vertices, VertexBuffer.PositionKind, false, false, 2);
        this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;
        this._createIndexBuffer();
      }
      _createIndexBuffer() {
        const engine = this._scene.getEngine();
        const indices = [];
        indices.push(0);
        indices.push(1);
        indices.push(2);
        indices.push(0);
        indices.push(2);
        indices.push(3);
        this._indexBuffer = engine.createIndexBuffer(indices);
      }
      /** @internal */
      _rebuild() {
        const vb = this._vertexBuffers[VertexBuffer.PositionKind];
        if (vb) {
          vb._rebuild();
        }
        this._createIndexBuffer();
      }
      /**
       * Checks if the layer is ready to be rendered
       * @returns true if the layer is ready. False otherwise.
       */
      isReady() {
        var _a;
        const engine = this._scene.getEngine();
        let defines = "";
        if (this.alphaTest) {
          defines = "#define ALPHATEST";
        }
        if (this.texture && !this.texture.gammaSpace) {
          defines += "\r\n#define LINEAR";
        }
        if (this._previousDefines !== defines) {
          this._previousDefines = defines;
          this._drawWrapper.effect = engine.createEffect("layer", [VertexBuffer.PositionKind], ["textureMatrix", "color", "scale", "offset"], ["textureSampler"], defines);
        }
        const currentEffect = this._drawWrapper.effect;
        return (currentEffect === null || currentEffect === void 0 ? void 0 : currentEffect.isReady()) && ((_a = this.texture) === null || _a === void 0 ? void 0 : _a.isReady());
      }
      /**
       * Renders the layer in the scene.
       */
      render() {
        if (!this.isEnabled) {
          return;
        }
        const engine = this._scene.getEngine();
        if (!this.isReady()) {
          return;
        }
        const currentEffect = this._drawWrapper.effect;
        this.onBeforeRenderObservable.notifyObservers(this);
        engine.enableEffect(this._drawWrapper);
        engine.setState(false);
        currentEffect.setTexture("textureSampler", this.texture);
        currentEffect.setMatrix("textureMatrix", this.texture.getTextureMatrix());
        currentEffect.setFloat4("color", this.color.r, this.color.g, this.color.b, this.color.a);
        currentEffect.setVector2("offset", this.offset);
        currentEffect.setVector2("scale", this.scale);
        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect);
        if (!this.alphaTest) {
          engine.setAlphaMode(this.alphaBlendingMode);
          engine.drawElementsType(Material.TriangleFillMode, 0, 6);
          engine.setAlphaMode(0);
        } else {
          engine.drawElementsType(Material.TriangleFillMode, 0, 6);
        }
        this.onAfterRenderObservable.notifyObservers(this);
      }
      /**
       * Disposes and releases the associated resources.
       */
      dispose() {
        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];
        if (vertexBuffer) {
          vertexBuffer.dispose();
          this._vertexBuffers[VertexBuffer.PositionKind] = null;
        }
        if (this._indexBuffer) {
          this._scene.getEngine()._releaseBuffer(this._indexBuffer);
          this._indexBuffer = null;
        }
        if (this.texture) {
          this.texture.dispose();
          this.texture = null;
        }
        this.renderTargetTextures = [];
        const index = this._scene.layers.indexOf(this);
        this._scene.layers.splice(index, 1);
        this.onDisposeObservable.notifyObservers(this);
        this.onDisposeObservable.clear();
        this.onAfterRenderObservable.clear();
        this.onBeforeRenderObservable.clear();
      }
    };
  }
});

export {
  init_engine_dynamicTexture,
  DynamicTexture,
  init_dynamicTexture,
  ClipboardEventTypes,
  ClipboardInfo,
  init_clipboardEvents,
  LayerSceneComponent,
  init_layerSceneComponent,
  Layer,
  init_layer
};
//# sourceMappingURL=chunk-AAZ73UPJ.js.map
