{
  "version": 3,
  "sources": ["../../../dev/core/src/Engines/Extensions/engine.dynamicTexture.ts", "../../../dev/core/src/Materials/Textures/dynamicTexture.ts", "../../../dev/core/src/Events/clipboardEvents.ts", "../../../dev/core/src/Layers/layerSceneComponent.ts", "../../../dev/core/src/Shaders/layer.fragment.ts", "../../../dev/core/src/Shaders/layer.vertex.ts", "../../../dev/core/src/Layers/layer.ts"],
  "sourcesContent": ["import { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICanvas } from \"../ICanvas\";\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Creates a dynamic texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param generateMipMaps defines if the engine should generate the mip levels\r\n         * @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)\r\n         * @returns the dynamic texture inside an InternalTexture\r\n         */\r\n        createDynamicTexture(width: number, height: number, generateMipMaps: boolean, samplingMode: number): InternalTexture;\r\n\r\n        /**\r\n         * Update the content of a dynamic texture\r\n         * @param texture defines the texture to update\r\n         * @param source defines the source containing the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param premulAlpha defines if alpha is stored as premultiplied\r\n         * @param format defines the format of the data\r\n         * @param forceBindTexture if the texture should be forced to be bound eg. after a graphics context loss (Default: false)\r\n         * @param allowGPUOptimization true to allow some specific GPU optimizations (subject to engine feature \"allowGPUOptimizationsForGUI\" being true)\r\n         */\r\n        updateDynamicTexture(\r\n            texture: Nullable<InternalTexture>,\r\n            source: ImageBitmap | ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | OffscreenCanvas | ICanvas,\r\n            invertY?: boolean,\r\n            premulAlpha?: boolean,\r\n            format?: number,\r\n            forceBindTexture?: boolean,\r\n            allowGPUOptimization?: boolean\r\n        ): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.createDynamicTexture = function (width: number, height: number, generateMipMaps: boolean, samplingMode: number): InternalTexture {\r\n    const texture = new InternalTexture(this, InternalTextureSource.Dynamic);\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n\r\n    if (generateMipMaps) {\r\n        width = this.needPOTTextures ? ThinEngine.GetExponentOfTwo(width, this._caps.maxTextureSize) : width;\r\n        height = this.needPOTTextures ? ThinEngine.GetExponentOfTwo(height, this._caps.maxTextureSize) : height;\r\n    }\r\n\r\n    //  this.resetTextureCache();\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.isReady = false;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n\r\n    this.updateTextureSamplingMode(samplingMode, texture);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nThinEngine.prototype.updateDynamicTexture = function (\r\n    texture: Nullable<InternalTexture>,\r\n    source: ImageBitmap | ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | OffscreenCanvas,\r\n    invertY?: boolean,\r\n    premulAlpha: boolean = false,\r\n    format?: number,\r\n    forceBindTexture: boolean = false,\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    allowGPUOptimization: boolean = false\r\n): void {\r\n    if (!texture) {\r\n        return;\r\n    }\r\n\r\n    const gl = this._gl;\r\n    const target = gl.TEXTURE_2D;\r\n\r\n    const wasPreviouslyBound = this._bindTextureDirectly(target, texture, true, forceBindTexture);\r\n\r\n    this._unpackFlipY(invertY === undefined ? texture.invertY : invertY);\r\n\r\n    if (premulAlpha) {\r\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);\r\n    }\r\n\r\n    const textureType = this._getWebGLTextureType(texture.type);\r\n    const glformat = this._getInternalFormat(format ? format : texture.format);\r\n    const internalFormat = this._getRGBABufferInternalSizedFormat(texture.type, glformat);\r\n\r\n    gl.texImage2D(target, 0, internalFormat, glformat, textureType, source as TexImageSource);\r\n\r\n    if (texture.generateMipMaps) {\r\n        gl.generateMipmap(target);\r\n    }\r\n\r\n    if (!wasPreviouslyBound) {\r\n        this._bindTextureDirectly(target, null);\r\n    }\r\n\r\n    if (premulAlpha) {\r\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);\r\n    }\r\n\r\n    texture.isReady = true;\r\n};\r\n", "import { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { ISize } from \"../../Maths/math.size\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport \"../../Engines/Extensions/engine.dynamicTexture\";\r\nimport type { ICanvas, ICanvasRenderingContext } from \"../../Engines/ICanvas\";\r\n\r\n/**\r\n * A class extending Texture allowing drawing on a texture\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/dynamicTexture\r\n */\r\nexport class DynamicTexture extends Texture {\r\n    private _generateMipMaps: boolean;\r\n    private _canvas: ICanvas;\r\n    private _context: ICanvasRenderingContext;\r\n\r\n    /**\r\n     * Creates a DynamicTexture\r\n     * @param name defines the name of the texture\r\n     * @param options provides 3 alternatives for width and height of texture, a canvas, object with width and height properties, number for both width and height\r\n     * @param scene defines the scene where you want the texture\r\n     * @param generateMipMaps defines the use of MinMaps or not (default is false)\r\n     * @param samplingMode defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)\r\n     * @param format defines the texture format to use (default is Engine.TEXTUREFORMAT_RGBA)\r\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading\r\n     */\r\n\r\n    constructor(\r\n        name: string,\r\n        options: any,\r\n        scene: Nullable<Scene> = null,\r\n        generateMipMaps: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA,\r\n        invertY?: boolean\r\n    ) {\r\n        super(null, scene, !generateMipMaps, invertY, samplingMode, undefined, undefined, undefined, undefined, format);\r\n\r\n        this.name = name;\r\n        this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n\r\n        this._generateMipMaps = generateMipMaps;\r\n\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return;\r\n        }\r\n\r\n        if (options.getContext) {\r\n            this._canvas = options;\r\n            this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);\r\n        } else {\r\n            this._canvas = engine.createCanvas(1, 1);\r\n\r\n            if (options.width || options.width === 0) {\r\n                this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);\r\n            } else {\r\n                this._texture = engine.createDynamicTexture(options, options, generateMipMaps, samplingMode);\r\n            }\r\n        }\r\n\r\n        const textureSize = this.getSize();\r\n\r\n        if (this._canvas.width !== textureSize.width) {\r\n            this._canvas.width = textureSize.width;\r\n        }\r\n        if (this._canvas.height !== textureSize.height) {\r\n            this._canvas.height = textureSize.height;\r\n        }\r\n        this._context = this._canvas.getContext(\"2d\");\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"DynamicTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"DynamicTexture\";\r\n    }\r\n\r\n    /**\r\n     * Gets the current state of canRescale\r\n     */\r\n    public get canRescale(): boolean {\r\n        return true;\r\n    }\r\n\r\n    private _recreate(textureSize: ISize): void {\r\n        this._canvas.width = textureSize.width;\r\n        this._canvas.height = textureSize.height;\r\n\r\n        this.releaseInternalTexture();\r\n\r\n        this._texture = this._getEngine()!.createDynamicTexture(textureSize.width, textureSize.height, this._generateMipMaps, this.samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Scales the texture\r\n     * @param ratio the scale factor to apply to both width and height\r\n     */\r\n    public scale(ratio: number): void {\r\n        const textureSize = this.getSize();\r\n\r\n        textureSize.width *= ratio;\r\n        textureSize.height *= ratio;\r\n\r\n        this._recreate(textureSize);\r\n    }\r\n\r\n    /**\r\n     * Resizes the texture\r\n     * @param width the new width\r\n     * @param height the new height\r\n     */\r\n    public scaleTo(width: number, height: number): void {\r\n        const textureSize = this.getSize();\r\n\r\n        textureSize.width = width;\r\n        textureSize.height = height;\r\n\r\n        this._recreate(textureSize);\r\n    }\r\n\r\n    /**\r\n     * Gets the context of the canvas used by the texture\r\n     * @returns the canvas context of the dynamic texture\r\n     */\r\n    public getContext(): ICanvasRenderingContext {\r\n        return this._context;\r\n    }\r\n\r\n    /**\r\n     * Clears the texture\r\n     */\r\n    public clear(): void {\r\n        const size = this.getSize();\r\n        this._context.fillRect(0, 0, size.width, size.height);\r\n    }\r\n\r\n    /**\r\n     * Updates the texture\r\n     * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\r\n     * @param premulAlpha defines if alpha is stored as premultiplied (default is false)\r\n     * @param allowGPUOptimization true to allow some specific GPU optimizations (subject to engine feature \"allowGPUOptimizationsForGUI\" being true)\r\n     */\r\n    public update(invertY?: boolean, premulAlpha = false, allowGPUOptimization = false): void {\r\n        this._getEngine()!.updateDynamicTexture(\r\n            this._texture,\r\n            this._canvas,\r\n            invertY === undefined ? true : invertY,\r\n            premulAlpha,\r\n            this._format || undefined,\r\n            undefined,\r\n            allowGPUOptimization\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Draws text onto the texture\r\n     * @param text defines the text to be drawn\r\n     * @param x defines the placement of the text from the left\r\n     * @param y defines the placement of the text from the top when invertY is true and from the bottom when false\r\n     * @param font defines the font to be used with font-style, font-size, font-name\r\n     * @param color defines the color used for the text\r\n     * @param clearColor defines the color for the canvas, use null to not overwrite canvas\r\n     * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\r\n     * @param update defines whether texture is immediately update (default is true)\r\n     */\r\n    public drawText(\r\n        text: string,\r\n        x: number | null | undefined,\r\n        y: number | null | undefined,\r\n        font: string,\r\n        color: string | null,\r\n        clearColor: string | null,\r\n        invertY?: boolean,\r\n        update = true\r\n    ) {\r\n        const size = this.getSize();\r\n        if (clearColor) {\r\n            this._context.fillStyle = clearColor;\r\n            this._context.fillRect(0, 0, size.width, size.height);\r\n        }\r\n\r\n        this._context.font = font;\r\n        if (x === null || x === undefined) {\r\n            const textSize = this._context.measureText(text);\r\n            x = (size.width - textSize.width) / 2;\r\n        }\r\n        if (y === null || y === undefined) {\r\n            const fontSize = parseInt(font.replace(/\\D/g, \"\"));\r\n            y = size.height / 2 + fontSize / 3.65;\r\n        }\r\n\r\n        this._context.fillStyle = color || \"\";\r\n        this._context.fillText(text, x, y);\r\n\r\n        if (update) {\r\n            this.update(invertY);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clones the texture\r\n     * @returns the clone of the texture.\r\n     */\r\n    public clone(): DynamicTexture {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return this;\r\n        }\r\n\r\n        const textureSize = this.getSize();\r\n        const newTexture = new DynamicTexture(this.name, textureSize, scene, this._generateMipMaps);\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // Dynamic Texture\r\n        newTexture.wrapU = this.wrapU;\r\n        newTexture.wrapV = this.wrapV;\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Serializes the dynamic texture.  The scene should be ready before the dynamic texture is serialized\r\n     * @returns a serialized dynamic texture object\r\n     */\r\n    public serialize(): any {\r\n        const scene = this.getScene();\r\n        if (scene && !scene.isReady()) {\r\n            Logger.Warn(\"The scene must be ready before serializing the dynamic texture\");\r\n        }\r\n\r\n        const serializationObject = super.serialize();\r\n        if (DynamicTexture._IsCanvasElement(this._canvas)) {\r\n            serializationObject.base64String = this._canvas.toDataURL();\r\n        }\r\n\r\n        serializationObject.invertY = this._invertY;\r\n        serializationObject.samplingMode = this.samplingMode;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    private static _IsCanvasElement(canvas: HTMLCanvasElement | OffscreenCanvas | ICanvas): canvas is HTMLCanvasElement {\r\n        return (canvas as HTMLCanvasElement).toDataURL !== undefined;\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        this.update();\r\n    }\r\n}\r\n", "/**\r\n * Gather the list of clipboard event types as constants.\r\n */\r\nexport class ClipboardEventTypes {\r\n    /**\r\n     * The clipboard event is fired when a copy command is active (pressed).\r\n     */\r\n    public static readonly COPY = 0x01; //\r\n    /**\r\n     *  The clipboard event is fired when a cut command is active (pressed).\r\n     */\r\n    public static readonly CUT = 0x02;\r\n\r\n    /**\r\n     * The clipboard event is fired when a paste command is active (pressed).\r\n     */\r\n    public static readonly PASTE = 0x03;\r\n}\r\n/**\r\n * This class is used to store clipboard related info for the onClipboardObservable event.\r\n */\r\nexport class ClipboardInfo {\r\n    /**\r\n     *Creates an instance of ClipboardInfo.\r\n     * @param type Defines the type of event (BABYLON.ClipboardEventTypes)\r\n     * @param event Defines the related dom event\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the type of event (BABYLON.ClipboardEventTypes)\r\n         */\r\n        public type: number,\r\n        /**\r\n         * Defines the related dom event\r\n         */\r\n        public event: ClipboardEvent\r\n    ) {}\r\n\r\n    /**\r\n     *  Get the clipboard event's type from the keycode.\r\n     * @param keyCode Defines the keyCode for the current keyboard event.\r\n     * @returns {number}\r\n     */\r\n    public static GetTypeFromCharacter(keyCode: number): number {\r\n        const charCode = keyCode;\r\n        //TODO: add codes for extended ASCII\r\n        switch (charCode) {\r\n            case 67:\r\n                return ClipboardEventTypes.COPY;\r\n            case 86:\r\n                return ClipboardEventTypes.PASTE;\r\n            case 88:\r\n                return ClipboardEventTypes.CUT;\r\n            default:\r\n                return -1;\r\n        }\r\n    }\r\n}\r\n", "import type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { ISceneComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport type { Layer } from \"./layer\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { AbstractScene } from \"../abstractScene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\ndeclare module \"../abstractScene\" {\r\n    export interface AbstractScene {\r\n        /**\r\n         * The list of layers (background and foreground) of the scene\r\n         */\r\n        layers: Array<Layer>;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines the layer scene component responsible to manage any layers\r\n * in a given scene.\r\n */\r\nexport class LayerSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_LAYER;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    private _engine: Engine;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene?: Scene) {\r\n        this.scene = scene || <Scene>EngineStore.LastCreatedScene;\r\n        if (!this.scene) {\r\n            return;\r\n        }\r\n        this._engine = this.scene.getEngine();\r\n        this.scene.layers = new Array<Layer>();\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_LAYER, this, this._drawCameraBackground);\r\n        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_LAYER, this, this._drawCameraForegroundWithPostProcessing);\r\n        this.scene._afterCameraPostProcessStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERAPOSTPROCESS_LAYER, this, this._drawCameraForegroundWithoutPostProcessing);\r\n\r\n        this.scene._beforeRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_LAYER, this, this._drawRenderTargetBackground);\r\n        this.scene._afterRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERTARGETDRAW_LAYER, this, this._drawRenderTargetForegroundWithPostProcessing);\r\n        this.scene._afterRenderTargetPostProcessStage.registerStep(\r\n            SceneComponentConstants.STEP_AFTERRENDERTARGETPOSTPROCESS_LAYER,\r\n            this,\r\n            this._drawRenderTargetForegroundWithoutPostProcessing\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        const layers = this.scene.layers;\r\n\r\n        for (const layer of layers) {\r\n            layer._rebuild();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        const layers = this.scene.layers;\r\n\r\n        while (layers.length) {\r\n            layers[0].dispose();\r\n        }\r\n    }\r\n\r\n    private _draw(predicate: (layer: Layer) => boolean): void {\r\n        const layers = this.scene.layers;\r\n\r\n        if (layers.length) {\r\n            this._engine.setDepthBuffer(false);\r\n            for (const layer of layers) {\r\n                if (predicate(layer)) {\r\n                    layer.render();\r\n                }\r\n            }\r\n            this._engine.setDepthBuffer(true);\r\n        }\r\n    }\r\n\r\n    private _drawCameraPredicate(layer: Layer, isBackground: boolean, applyPostProcess: boolean, cameraLayerMask: number): boolean {\r\n        return (\r\n            !layer.renderOnlyInRenderTargetTextures &&\r\n            layer.isBackground === isBackground &&\r\n            layer.applyPostProcess === applyPostProcess &&\r\n            (layer.layerMask & cameraLayerMask) !== 0\r\n        );\r\n    }\r\n\r\n    private _drawCameraBackground(camera: Camera): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawCameraPredicate(layer, true, true, camera.layerMask);\r\n        });\r\n    }\r\n\r\n    private _drawCameraForegroundWithPostProcessing(camera: Camera): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawCameraPredicate(layer, false, true, camera.layerMask);\r\n        });\r\n    }\r\n\r\n    private _drawCameraForegroundWithoutPostProcessing(camera: Camera): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawCameraPredicate(layer, false, false, camera.layerMask);\r\n        });\r\n    }\r\n\r\n    private _drawRenderTargetPredicate(layer: Layer, isBackground: boolean, applyPostProcess: boolean, cameraLayerMask: number, renderTargetTexture: RenderTargetTexture): boolean {\r\n        return (\r\n            layer.renderTargetTextures.length > 0 &&\r\n            layer.isBackground === isBackground &&\r\n            layer.applyPostProcess === applyPostProcess &&\r\n            layer.renderTargetTextures.indexOf(renderTargetTexture) > -1 &&\r\n            (layer.layerMask & cameraLayerMask) !== 0\r\n        );\r\n    }\r\n\r\n    private _drawRenderTargetBackground(renderTarget: RenderTargetTexture): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawRenderTargetPredicate(layer, true, true, this.scene.activeCamera!.layerMask, renderTarget);\r\n        });\r\n    }\r\n\r\n    private _drawRenderTargetForegroundWithPostProcessing(renderTarget: RenderTargetTexture): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawRenderTargetPredicate(layer, false, true, this.scene.activeCamera!.layerMask, renderTarget);\r\n        });\r\n    }\r\n\r\n    private _drawRenderTargetForegroundWithoutPostProcessing(renderTarget: RenderTargetTexture): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawRenderTargetPredicate(layer, false, false, this.scene.activeCamera!.layerMask, renderTarget);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds all the elements from the container to the scene\r\n     * @param container the container holding the elements\r\n     */\r\n    public addFromContainer(container: AbstractScene): void {\r\n        if (!container.layers) {\r\n            return;\r\n        }\r\n        container.layers.forEach((layer) => {\r\n            this.scene.layers.push(layer);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Removes all the elements in the container from the scene\r\n     * @param container contains the elements to remove\r\n     * @param dispose if the removed element should be disposed (default: false)\r\n     */\r\n    public removeFromContainer(container: AbstractScene, dispose = false): void {\r\n        if (!container.layers) {\r\n            return;\r\n        }\r\n        container.layers.forEach((layer) => {\r\n            const index = this.scene.layers.indexOf(layer);\r\n            if (index !== -1) {\r\n                this.scene.layers.splice(index, 1);\r\n            }\r\n            if (dispose) {\r\n                layer.dispose();\r\n            }\r\n        });\r\n    }\r\n}\r\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/helperFunctions\";\n\nconst name = \"layerPixelShader\";\nconst shader = `varying vec2 vUV;\runiform sampler2D textureSampler;\runiform vec4 color;\r#include<helperFunctions>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_FRAGMENT_MAIN_BEGIN\nvec4 baseColor=texture2D(textureSampler,vUV);\r#ifdef LINEAR\nbaseColor.rgb=toGammaSpace(baseColor.rgb);\r#endif\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\rdiscard;\r#endif\ngl_FragColor=baseColor*color;\r#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const layerPixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"layerVertexShader\";\nconst shader = `attribute vec2 position;\runiform vec2 scale;\runiform vec2 offset;\runiform mat4 textureMatrix;\rvarying vec2 vUV;\rconst vec2 madd=vec2(0.5,0.5);\r#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_VERTEX_MAIN_BEGIN\nvec2 shiftedPosition=position*scale+offset;\rvUV=vec2(textureMatrix*vec4(shiftedPosition*madd+madd,1.0,0.0));\rgl_Position=vec4(shiftedPosition,0.0,1.0);\r#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const layerVertexShader = { name, shader };\n", "import type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { LayerSceneComponent } from \"./layerSceneComponent\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\n\r\nimport \"../Shaders/layer.fragment\";\r\nimport \"../Shaders/layer.vertex\";\r\n\r\n/**\r\n * This represents a full screen 2d layer.\r\n * This can be useful to display a picture in the  background of your scene for instance.\r\n * @see https://www.babylonjs-playground.com/#08A2BS#1\r\n */\r\nexport class Layer {\r\n    /**\r\n     * Define the texture the layer should display.\r\n     */\r\n    public texture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Is the layer in background or foreground.\r\n     */\r\n    public isBackground: boolean;\r\n\r\n    private _applyPostProcess: boolean = true;\r\n    /**\r\n     * Determines if the layer is drawn before (true) or after (false) post-processing.\r\n     * If the layer is background, it is always before.\r\n     */\r\n    public set applyPostProcess(value: boolean) {\r\n        this._applyPostProcess = value;\r\n    }\r\n    public get applyPostProcess(): boolean {\r\n        return this.isBackground || this._applyPostProcess;\r\n    }\r\n\r\n    /**\r\n     * Define the color of the layer (instead of texture).\r\n     */\r\n    public color: Color4;\r\n\r\n    /**\r\n     * Define the scale of the layer in order to zoom in out of the texture.\r\n     */\r\n    public scale = new Vector2(1, 1);\r\n\r\n    /**\r\n     * Define an offset for the layer in order to shift the texture.\r\n     */\r\n    public offset = new Vector2(0, 0);\r\n\r\n    /**\r\n     * Define the alpha blending mode used in the layer in case the texture or color has an alpha.\r\n     */\r\n    public alphaBlendingMode = Constants.ALPHA_COMBINE;\r\n\r\n    /**\r\n     * Define if the layer should alpha test or alpha blend with the rest of the scene.\r\n     * Alpha test will not mix with the background color in case of transparency.\r\n     * It will either use the texture color or the background depending on the alpha value of the current pixel.\r\n     */\r\n    public alphaTest: boolean;\r\n\r\n    /**\r\n     * Define a mask to restrict the layer to only some of the scene cameras.\r\n     */\r\n    public layerMask: number = 0x0fffffff;\r\n\r\n    /**\r\n     * Define the list of render target the layer is visible into.\r\n     */\r\n    public renderTargetTextures: RenderTargetTexture[] = [];\r\n\r\n    /**\r\n     * Define if the layer is only used in renderTarget or if it also\r\n     * renders in the main frame buffer of the canvas.\r\n     */\r\n    public renderOnlyInRenderTargetTextures = false;\r\n\r\n    /**\r\n     * Define if the layer is enabled (ie. should be displayed). Default: true\r\n     */\r\n    public isEnabled = true;\r\n\r\n    private _scene: Scene;\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _drawWrapper: DrawWrapper;\r\n    private _previousDefines: string;\r\n\r\n    /**\r\n     * An event triggered when the layer is disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<Layer>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<Layer>>;\r\n    /**\r\n     * Back compatibility with callback before the onDisposeObservable existed.\r\n     * The set callback will be triggered when the layer has been disposed.\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered before rendering the scene\r\n     */\r\n    public onBeforeRenderObservable = new Observable<Layer>();\r\n\r\n    private _onBeforeRenderObserver: Nullable<Observer<Layer>>;\r\n    /**\r\n     * Back compatibility with callback before the onBeforeRenderObservable existed.\r\n     * The set callback will be triggered just before rendering the layer.\r\n     */\r\n    public set onBeforeRender(callback: () => void) {\r\n        if (this._onBeforeRenderObserver) {\r\n            this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\r\n        }\r\n        this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered after rendering the scene\r\n     */\r\n    public onAfterRenderObservable = new Observable<Layer>();\r\n\r\n    private _onAfterRenderObserver: Nullable<Observer<Layer>>;\r\n    /**\r\n     * Back compatibility with callback before the onAfterRenderObservable existed.\r\n     * The set callback will be triggered just after rendering the layer.\r\n     */\r\n    public set onAfterRender(callback: () => void) {\r\n        if (this._onAfterRenderObserver) {\r\n            this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\r\n        }\r\n        this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new layer.\r\n     * This represents a full screen 2d layer.\r\n     * This can be useful to display a picture in the  background of your scene for instance.\r\n     * @see https://www.babylonjs-playground.com/#08A2BS#1\r\n     * @param name Define the name of the layer in the scene\r\n     * @param imgUrl Define the url of the texture to display in the layer\r\n     * @param scene Define the scene the layer belongs to\r\n     * @param isBackground Defines whether the layer is displayed in front or behind the scene\r\n     * @param color Defines a color for the layer\r\n     */\r\n    constructor(\r\n        /**\r\n         * Define the name of the layer.\r\n         */\r\n        public name: string,\r\n        imgUrl: Nullable<string>,\r\n        scene: Nullable<Scene>,\r\n        isBackground?: boolean,\r\n        color?: Color4\r\n    ) {\r\n        this.texture = imgUrl ? new Texture(imgUrl, scene, true) : null;\r\n        this.isBackground = isBackground === undefined ? true : isBackground;\r\n        this.color = color === undefined ? new Color4(1, 1, 1, 1) : color;\r\n\r\n        this._scene = <Scene>(scene || EngineStore.LastCreatedScene);\r\n        let layerComponent = this._scene._getComponent(SceneComponentConstants.NAME_LAYER) as LayerSceneComponent;\r\n        if (!layerComponent) {\r\n            layerComponent = new LayerSceneComponent(this._scene);\r\n            this._scene._addComponent(layerComponent);\r\n        }\r\n        this._scene.layers.push(this);\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        this._drawWrapper = new DrawWrapper(engine);\r\n\r\n        // VBO\r\n        const vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        const vertexBuffer = new VertexBuffer(engine, vertices, VertexBuffer.PositionKind, false, false, 2);\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;\r\n\r\n        this._createIndexBuffer();\r\n    }\r\n\r\n    private _createIndexBuffer(): void {\r\n        const engine = this._scene.getEngine();\r\n\r\n        // Indices\r\n        const indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = engine.createIndexBuffer(indices);\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        const vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n\r\n        if (vb) {\r\n            vb._rebuild();\r\n        }\r\n\r\n        this._createIndexBuffer();\r\n    }\r\n\r\n    /**\r\n     * Checks if the layer is ready to be rendered\r\n     * @returns true if the layer is ready. False otherwise.\r\n     */\r\n    public isReady() {\r\n        const engine = this._scene.getEngine();\r\n\r\n        let defines = \"\";\r\n\r\n        if (this.alphaTest) {\r\n            defines = \"#define ALPHATEST\";\r\n        }\r\n\r\n        if (this.texture && !this.texture.gammaSpace) {\r\n            defines += \"\\r\\n#define LINEAR\";\r\n        }\r\n\r\n        if (this._previousDefines !== defines) {\r\n            this._previousDefines = defines;\r\n            this._drawWrapper.effect = engine.createEffect(\"layer\", [VertexBuffer.PositionKind], [\"textureMatrix\", \"color\", \"scale\", \"offset\"], [\"textureSampler\"], defines);\r\n        }\r\n\r\n        const currentEffect = this._drawWrapper.effect;\r\n\r\n        return currentEffect?.isReady() && this.texture?.isReady();\r\n    }\r\n\r\n    /**\r\n     * Renders the layer in the scene.\r\n     */\r\n    public render(): void {\r\n        if (!this.isEnabled) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        // Check\r\n        if (!this.isReady()) {\r\n            return;\r\n        }\r\n\r\n        const currentEffect = this._drawWrapper.effect!;\r\n\r\n        this.onBeforeRenderObservable.notifyObservers(this);\r\n\r\n        // Render\r\n        engine.enableEffect(this._drawWrapper);\r\n        engine.setState(false);\r\n\r\n        // Texture\r\n        currentEffect.setTexture(\"textureSampler\", this.texture);\r\n        currentEffect.setMatrix(\"textureMatrix\", this.texture!.getTextureMatrix());\r\n\r\n        // Color\r\n        currentEffect.setFloat4(\"color\", this.color.r, this.color.g, this.color.b, this.color.a);\r\n\r\n        // Scale / offset\r\n        currentEffect.setVector2(\"offset\", this.offset);\r\n        currentEffect.setVector2(\"scale\", this.scale);\r\n\r\n        // VBOs\r\n        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect);\r\n\r\n        // Draw order\r\n        if (!this.alphaTest) {\r\n            engine.setAlphaMode(this.alphaBlendingMode);\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n            engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n        } else {\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n        }\r\n\r\n        this.onAfterRenderObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Disposes and releases the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._scene.getEngine()._releaseBuffer(this._indexBuffer);\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        if (this.texture) {\r\n            this.texture.dispose();\r\n            this.texture = null;\r\n        }\r\n\r\n        // Clean RTT list\r\n        this.renderTargetTextures = [];\r\n\r\n        // Remove from scene\r\n        const index = this._scene.layers.indexOf(this);\r\n        this._scene.layers.splice(index, 1);\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n\r\n        this.onDisposeObservable.clear();\r\n        this.onAfterRenderObservable.clear();\r\n        this.onBeforeRenderObservable.clear();\r\n    }\r\n}\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;AACA;AAsCA,eAAW,UAAU,uBAAuB,SAAU,OAAe,QAAgB,iBAA0B,cAAoB;AAC/H,YAAM,UAAU,IAAI,gBAAgB,MAAM,sBAAsB,OAAO;AACvE,cAAQ,YAAY;AACpB,cAAQ,aAAa;AAErB,UAAI,iBAAiB;AACjB,gBAAQ,KAAK,kBAAkB,WAAW,iBAAiB,OAAO,KAAK,MAAM,cAAc,IAAI;AAC/F,iBAAS,KAAK,kBAAkB,WAAW,iBAAiB,QAAQ,KAAK,MAAM,cAAc,IAAI;;AAIrG,cAAQ,QAAQ;AAChB,cAAQ,SAAS;AACjB,cAAQ,UAAU;AAClB,cAAQ,kBAAkB;AAC1B,cAAQ,eAAe;AAEvB,WAAK,0BAA0B,cAAc,OAAO;AAEpD,WAAK,uBAAuB,KAAK,OAAO;AAExC,aAAO;IACX;AAEA,eAAW,UAAU,uBAAuB,SACxC,SACA,QACA,SACA,cAAuB,OACvB,QACA,mBAA4B,OAE5B,uBAAgC,OAAK;AAErC,UAAI,CAAC,SAAS;AACV;;AAGJ,YAAM,KAAK,KAAK;AAChB,YAAM,SAAS,GAAG;AAElB,YAAM,qBAAqB,KAAK,qBAAqB,QAAQ,SAAS,MAAM,gBAAgB;AAE5F,WAAK,aAAa,YAAY,SAAY,QAAQ,UAAU,OAAO;AAEnE,UAAI,aAAa;AACb,WAAG,YAAY,GAAG,gCAAgC,CAAC;;AAGvD,YAAM,cAAc,KAAK,qBAAqB,QAAQ,IAAI;AAC1D,YAAM,WAAW,KAAK,mBAAmB,SAAS,SAAS,QAAQ,MAAM;AACzE,YAAM,iBAAiB,KAAK,kCAAkC,QAAQ,MAAM,QAAQ;AAEpF,SAAG,WAAW,QAAQ,GAAG,gBAAgB,UAAU,aAAa,MAAwB;AAExF,UAAI,QAAQ,iBAAiB;AACzB,WAAG,eAAe,MAAM;;AAG5B,UAAI,CAAC,oBAAoB;AACrB,aAAK,qBAAqB,QAAQ,IAAI;;AAG1C,UAAI,aAAa;AACb,WAAG,YAAY,GAAG,gCAAgC,CAAC;;AAGvD,cAAQ,UAAU;IACtB;;;;;AC3GA,IAaa;AAbb;;;AAIA;AAEA;AAOM,IAAO,iBAAP,MAAO,wBAAuB,QAAO;;;;;;;;;;;MAgBvC,YACIA,OACA,SACA,QAAyB,MACzB,kBAA2B,OAC3B,eAAuB,GAAA,SAAU,GAAA,SAAA;AAIjC,cAAM,MAAM,OAAO,CAAC,iBAAiB,SAAS,cAAc,QAAW,QAAW,QAAW,QAAW,MAAM;AAE9G,aAAK,OAAOA;AACZ,aAAK,QAAQ,QAAQ;AACrB,aAAK,QAAQ,QAAQ;AAErB,aAAK,mBAAmB;AAExB,cAAM,SAAS,KAAK,WAAU;AAC9B,YAAI,CAAC,QAAQ;AACT;;AAGJ,YAAI,QAAQ,YAAY;AACpB,eAAK,UAAU;AACf,eAAK,WAAW,OAAO,qBAAqB,QAAQ,OAAO,QAAQ,QAAQ,iBAAiB,YAAY;eACrG;AACH,eAAK,UAAU,OAAO,aAAa,GAAG,CAAC;AAEvC,cAAI,QAAQ,SAAS,QAAQ,UAAU,GAAG;AACtC,iBAAK,WAAW,OAAO,qBAAqB,QAAQ,OAAO,QAAQ,QAAQ,iBAAiB,YAAY;iBACrG;AACH,iBAAK,WAAW,OAAO,qBAAqB,SAAS,SAAS,iBAAiB,YAAY;;;AAInG,cAAM,cAAc,KAAK,QAAO;AAEhC,YAAI,KAAK,QAAQ,UAAU,YAAY,OAAO;AAC1C,eAAK,QAAQ,QAAQ,YAAY;;AAErC,YAAI,KAAK,QAAQ,WAAW,YAAY,QAAQ;AAC5C,eAAK,QAAQ,SAAS,YAAY;;AAEtC,aAAK,WAAW,KAAK,QAAQ,WAAW,IAAI;MAChD;;;;;MAMO,eAAY;AACf,eAAO;MACX;;;;MAKA,IAAW,aAAU;AACjB,eAAO;MACX;MAEQ,UAAU,aAAkB;AAChC,aAAK,QAAQ,QAAQ,YAAY;AACjC,aAAK,QAAQ,SAAS,YAAY;AAElC,aAAK,uBAAsB;AAE3B,aAAK,WAAW,KAAK,WAAU,EAAI,qBAAqB,YAAY,OAAO,YAAY,QAAQ,KAAK,kBAAkB,KAAK,YAAY;MAC3I;;;;;MAMO,MAAM,OAAa;AACtB,cAAM,cAAc,KAAK,QAAO;AAEhC,oBAAY,SAAS;AACrB,oBAAY,UAAU;AAEtB,aAAK,UAAU,WAAW;MAC9B;;;;;;MAOO,QAAQ,OAAe,QAAc;AACxC,cAAM,cAAc,KAAK,QAAO;AAEhC,oBAAY,QAAQ;AACpB,oBAAY,SAAS;AAErB,aAAK,UAAU,WAAW;MAC9B;;;;;MAMO,aAAU;AACb,eAAO,KAAK;MAChB;;;;MAKO,QAAK;AACR,cAAM,OAAO,KAAK,QAAO;AACzB,aAAK,SAAS,SAAS,GAAG,GAAG,KAAK,OAAO,KAAK,MAAM;MACxD;;;;;;;MAQO,OAAO,SAAmB,cAAc,OAAO,uBAAuB,OAAK;AAC9E,aAAK,WAAU,EAAI,qBACf,KAAK,UACL,KAAK,SACL,YAAY,SAAY,OAAO,SAC/B,aACA,KAAK,WAAW,QAChB,QACA,oBAAoB;MAE5B;;;;;;;;;;;;MAaO,SACH,MACA,GACA,GACA,MACA,OACA,YACA,SACA,SAAS,MAAI;AAEb,cAAM,OAAO,KAAK,QAAO;AACzB,YAAI,YAAY;AACZ,eAAK,SAAS,YAAY;AAC1B,eAAK,SAAS,SAAS,GAAG,GAAG,KAAK,OAAO,KAAK,MAAM;;AAGxD,aAAK,SAAS,OAAO;AACrB,YAAI,MAAM,QAAQ,MAAM,QAAW;AAC/B,gBAAM,WAAW,KAAK,SAAS,YAAY,IAAI;AAC/C,eAAK,KAAK,QAAQ,SAAS,SAAS;;AAExC,YAAI,MAAM,QAAQ,MAAM,QAAW;AAC/B,gBAAM,WAAW,SAAS,KAAK,QAAQ,OAAO,EAAE,CAAC;AACjD,cAAI,KAAK,SAAS,IAAI,WAAW;;AAGrC,aAAK,SAAS,YAAY,SAAS;AACnC,aAAK,SAAS,SAAS,MAAM,GAAG,CAAC;AAEjC,YAAI,QAAQ;AACR,eAAK,OAAO,OAAO;;MAE3B;;;;;MAMO,QAAK;AACR,cAAM,QAAQ,KAAK,SAAQ;AAE3B,YAAI,CAAC,OAAO;AACR,iBAAO;;AAGX,cAAM,cAAc,KAAK,QAAO;AAChC,cAAM,aAAa,IAAI,gBAAe,KAAK,MAAM,aAAa,OAAO,KAAK,gBAAgB;AAG1F,mBAAW,WAAW,KAAK;AAC3B,mBAAW,QAAQ,KAAK;AAGxB,mBAAW,QAAQ,KAAK;AACxB,mBAAW,QAAQ,KAAK;AAExB,eAAO;MACX;;;;;MAMO,YAAS;AACZ,cAAM,QAAQ,KAAK,SAAQ;AAC3B,YAAI,SAAS,CAAC,MAAM,QAAO,GAAI;AAC3B,iBAAO,KAAK,gEAAgE;;AAGhF,cAAM,sBAAsB,MAAM,UAAS;AAC3C,YAAI,gBAAe,iBAAiB,KAAK,OAAO,GAAG;AAC/C,8BAAoB,eAAe,KAAK,QAAQ,UAAS;;AAG7D,4BAAoB,UAAU,KAAK;AACnC,4BAAoB,eAAe,KAAK;AAExC,eAAO;MACX;MAEQ,OAAO,iBAAiB,QAAqD;AACjF,eAAQ,OAA6B,cAAc;MACvD;;MAGO,WAAQ;AACX,aAAK,OAAM;MACf;;;;;;AClQJ,IAGa,qBAkBA;AArBb;;AAGM,IAAO,sBAAP,MAA0B;;AAIL,wBAAA,OAAO;AAIP,wBAAA,MAAM;AAKN,wBAAA,QAAQ;AAK7B,IAAO,gBAAP,MAAoB;;;;;;MAMtB,YAIW,MAIA,OAAqB;AAJrB,aAAA,OAAA;AAIA,aAAA,QAAA;MACR;;;;;;MAOI,OAAO,qBAAqB,SAAe;AAC9C,cAAM,WAAW;AAEjB,gBAAQ,UAAU;UACd,KAAK;AACD,mBAAO,oBAAoB;UAC/B,KAAK;AACD,mBAAO,oBAAoB;UAC/B,KAAK;AACD,mBAAO,oBAAoB;UAC/B;AACI,mBAAO;;MAEnB;;;;;;ACpDJ,IAmBa;AAnBb;;;AAIA;AAeM,IAAO,sBAAP,MAA0B;;;;;MAiB5B,YAAY,OAAa;AAbT,aAAA,OAAO,wBAAwB;AAc3C,aAAK,QAAQ,SAAgB,YAAY;AACzC,YAAI,CAAC,KAAK,OAAO;AACb;;AAEJ,aAAK,UAAU,KAAK,MAAM,UAAS;AACnC,aAAK,MAAM,SAAS,IAAI,MAAK;MACjC;;;;MAKO,WAAQ;AACX,aAAK,MAAM,uBAAuB,aAAa,wBAAwB,6BAA6B,MAAM,KAAK,qBAAqB;AACpI,aAAK,MAAM,sBAAsB,aAAa,wBAAwB,4BAA4B,MAAM,KAAK,uCAAuC;AACpJ,aAAK,MAAM,6BAA6B,aAAa,wBAAwB,mCAAmC,MAAM,KAAK,0CAA0C;AAErK,aAAK,MAAM,6BAA6B,aAAa,wBAAwB,mCAAmC,MAAM,KAAK,2BAA2B;AACtJ,aAAK,MAAM,4BAA4B,aAAa,wBAAwB,kCAAkC,MAAM,KAAK,6CAA6C;AACtK,aAAK,MAAM,mCAAmC,aAC1C,wBAAwB,yCACxB,MACA,KAAK,gDAAgD;MAE7D;;;;;MAMO,UAAO;AACV,cAAM,SAAS,KAAK,MAAM;AAE1B,mBAAW,SAAS,QAAQ;AACxB,gBAAM,SAAQ;;MAEtB;;;;MAKO,UAAO;AACV,cAAM,SAAS,KAAK,MAAM;AAE1B,eAAO,OAAO,QAAQ;AAClB,iBAAO,CAAC,EAAE,QAAO;;MAEzB;MAEQ,MAAM,WAAoC;AAC9C,cAAM,SAAS,KAAK,MAAM;AAE1B,YAAI,OAAO,QAAQ;AACf,eAAK,QAAQ,eAAe,KAAK;AACjC,qBAAW,SAAS,QAAQ;AACxB,gBAAI,UAAU,KAAK,GAAG;AAClB,oBAAM,OAAM;;;AAGpB,eAAK,QAAQ,eAAe,IAAI;;MAExC;MAEQ,qBAAqB,OAAc,cAAuB,kBAA2B,iBAAuB;AAChH,eACI,CAAC,MAAM,oCACP,MAAM,iBAAiB,gBACvB,MAAM,qBAAqB,qBAC1B,MAAM,YAAY,qBAAqB;MAEhD;MAEQ,sBAAsB,QAAc;AACxC,aAAK,MAAM,CAAC,UAAgB;AACxB,iBAAO,KAAK,qBAAqB,OAAO,MAAM,MAAM,OAAO,SAAS;QACxE,CAAC;MACL;MAEQ,wCAAwC,QAAc;AAC1D,aAAK,MAAM,CAAC,UAAgB;AACxB,iBAAO,KAAK,qBAAqB,OAAO,OAAO,MAAM,OAAO,SAAS;QACzE,CAAC;MACL;MAEQ,2CAA2C,QAAc;AAC7D,aAAK,MAAM,CAAC,UAAgB;AACxB,iBAAO,KAAK,qBAAqB,OAAO,OAAO,OAAO,OAAO,SAAS;QAC1E,CAAC;MACL;MAEQ,2BAA2B,OAAc,cAAuB,kBAA2B,iBAAyB,qBAAwC;AAChK,eACI,MAAM,qBAAqB,SAAS,KACpC,MAAM,iBAAiB,gBACvB,MAAM,qBAAqB,oBAC3B,MAAM,qBAAqB,QAAQ,mBAAmB,IAAI,OACzD,MAAM,YAAY,qBAAqB;MAEhD;MAEQ,4BAA4B,cAAiC;AACjE,aAAK,MAAM,CAAC,UAAgB;AACxB,iBAAO,KAAK,2BAA2B,OAAO,MAAM,MAAM,KAAK,MAAM,aAAc,WAAW,YAAY;QAC9G,CAAC;MACL;MAEQ,8CAA8C,cAAiC;AACnF,aAAK,MAAM,CAAC,UAAgB;AACxB,iBAAO,KAAK,2BAA2B,OAAO,OAAO,MAAM,KAAK,MAAM,aAAc,WAAW,YAAY;QAC/G,CAAC;MACL;MAEQ,iDAAiD,cAAiC;AACtF,aAAK,MAAM,CAAC,UAAgB;AACxB,iBAAO,KAAK,2BAA2B,OAAO,OAAO,OAAO,KAAK,MAAM,aAAc,WAAW,YAAY;QAChH,CAAC;MACL;;;;;MAMO,iBAAiB,WAAwB;AAC5C,YAAI,CAAC,UAAU,QAAQ;AACnB;;AAEJ,kBAAU,OAAO,QAAQ,CAAC,UAAS;AAC/B,eAAK,MAAM,OAAO,KAAK,KAAK;QAChC,CAAC;MACL;;;;;;MAOO,oBAAoB,WAA0B,UAAU,OAAK;AAChE,YAAI,CAAC,UAAU,QAAQ;AACnB;;AAEJ,kBAAU,OAAO,QAAQ,CAAC,UAAS;AAC/B,gBAAM,QAAQ,KAAK,MAAM,OAAO,QAAQ,KAAK;AAC7C,cAAI,UAAU,IAAI;AACd,iBAAK,MAAM,OAAO,OAAO,OAAO,CAAC;;AAErC,cAAI,SAAS;AACT,kBAAM,QAAO;;QAErB,CAAC;MACL;;;;;;AC7LJ,IAIM,MACA;AALN;;AACA;AACA;AAEA,IAAM,OAAO;AACb,IAAM,SAAS;;;;;;;;;;;;;;;;;;AAmBf,gBAAY,aAAa,IAAI,IAAI;;;;;ACxBjC,IAGMC,OACAC;AAJN;;AACA;AAEA,IAAMD,QAAO;AACb,IAAMC,UAAS;;;;;;;;;;;;;;AAef,gBAAY,aAAaD,KAAI,IAAIC;;;;;AClBjC,IAyBa;AAzBb;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AAEA;AACA;AAOM,IAAO,QAAP,MAAY;;;;;MAgBd,IAAW,iBAAiB,OAAc;AACtC,aAAK,oBAAoB;MAC7B;MACA,IAAW,mBAAgB;AACvB,eAAO,KAAK,gBAAgB,KAAK;MACrC;;;;;MAkEA,IAAW,UAAU,UAAoB;AACrC,YAAI,KAAK,oBAAoB;AACzB,eAAK,oBAAoB,OAAO,KAAK,kBAAkB;;AAE3D,aAAK,qBAAqB,KAAK,oBAAoB,IAAI,QAAQ;MACnE;;;;;MAYA,IAAW,eAAe,UAAoB;AAC1C,YAAI,KAAK,yBAAyB;AAC9B,eAAK,yBAAyB,OAAO,KAAK,uBAAuB;;AAErE,aAAK,0BAA0B,KAAK,yBAAyB,IAAI,QAAQ;MAC7E;;;;;MAYA,IAAW,cAAc,UAAoB;AACzC,YAAI,KAAK,wBAAwB;AAC7B,eAAK,wBAAwB,OAAO,KAAK,sBAAsB;;AAEnE,aAAK,yBAAyB,KAAK,wBAAwB,IAAI,QAAQ;MAC3E;;;;;;;;;;;;MAaA,YAIWC,OACP,QACA,OACA,cACA,OAAc;AAJP,aAAA,OAAAA;AApIH,aAAA,oBAA6B;AAoB9B,aAAA,QAAQ,IAAI,QAAQ,GAAG,CAAC;AAKxB,aAAA,SAAS,IAAI,QAAQ,GAAG,CAAC;AAKzB,aAAA,oBAAoB;AAYpB,aAAA,YAAoB;AAKpB,aAAA,uBAA8C,CAAA;AAM9C,aAAA,mCAAmC;AAKnC,aAAA,YAAY;AAGX,aAAA,iBAA4D,CAAA;AAQ7D,aAAA,sBAAsB,IAAI,WAAU;AAiBpC,aAAA,2BAA2B,IAAI,WAAU;AAiBzC,aAAA,0BAA0B,IAAI,WAAU;AAmC3C,aAAK,UAAU,SAAS,IAAI,QAAQ,QAAQ,OAAO,IAAI,IAAI;AAC3D,aAAK,eAAe,iBAAiB,SAAY,OAAO;AACxD,aAAK,QAAQ,UAAU,SAAY,IAAI,OAAO,GAAG,GAAG,GAAG,CAAC,IAAI;AAE5D,aAAK,SAAiB,SAAS,YAAY;AAC3C,YAAI,iBAAiB,KAAK,OAAO,cAAc,wBAAwB,UAAU;AACjF,YAAI,CAAC,gBAAgB;AACjB,2BAAiB,IAAI,oBAAoB,KAAK,MAAM;AACpD,eAAK,OAAO,cAAc,cAAc;;AAE5C,aAAK,OAAO,OAAO,KAAK,IAAI;AAE5B,cAAM,SAAS,KAAK,OAAO,UAAS;AAEpC,aAAK,eAAe,IAAI,YAAY,MAAM;AAG1C,cAAM,WAAW,CAAA;AACjB,iBAAS,KAAK,GAAG,CAAC;AAClB,iBAAS,KAAK,IAAI,CAAC;AACnB,iBAAS,KAAK,IAAI,EAAE;AACpB,iBAAS,KAAK,GAAG,EAAE;AAEnB,cAAM,eAAe,IAAI,aAAa,QAAQ,UAAU,aAAa,cAAc,OAAO,OAAO,CAAC;AAClG,aAAK,eAAe,aAAa,YAAY,IAAI;AAEjD,aAAK,mBAAkB;MAC3B;MAEQ,qBAAkB;AACtB,cAAM,SAAS,KAAK,OAAO,UAAS;AAGpC,cAAM,UAAU,CAAA;AAChB,gBAAQ,KAAK,CAAC;AACd,gBAAQ,KAAK,CAAC;AACd,gBAAQ,KAAK,CAAC;AAEd,gBAAQ,KAAK,CAAC;AACd,gBAAQ,KAAK,CAAC;AACd,gBAAQ,KAAK,CAAC;AAEd,aAAK,eAAe,OAAO,kBAAkB,OAAO;MACxD;;MAGO,WAAQ;AACX,cAAM,KAAK,KAAK,eAAe,aAAa,YAAY;AAExD,YAAI,IAAI;AACJ,aAAG,SAAQ;;AAGf,aAAK,mBAAkB;MAC3B;;;;;MAMO,UAAO;;AACV,cAAM,SAAS,KAAK,OAAO,UAAS;AAEpC,YAAI,UAAU;AAEd,YAAI,KAAK,WAAW;AAChB,oBAAU;;AAGd,YAAI,KAAK,WAAW,CAAC,KAAK,QAAQ,YAAY;AAC1C,qBAAW;;AAGf,YAAI,KAAK,qBAAqB,SAAS;AACnC,eAAK,mBAAmB;AACxB,eAAK,aAAa,SAAS,OAAO,aAAa,SAAS,CAAC,aAAa,YAAY,GAAG,CAAC,iBAAiB,SAAS,SAAS,QAAQ,GAAG,CAAC,gBAAgB,GAAG,OAAO;;AAGnK,cAAM,gBAAgB,KAAK,aAAa;AAExC,gBAAO,kBAAa,QAAb,kBAAa,SAAA,SAAb,cAAe,QAAO,QAAM,KAAA,KAAK,aAAO,QAAA,OAAA,SAAA,SAAA,GAAE,QAAO;MAC5D;;;;MAKO,SAAM;AACT,YAAI,CAAC,KAAK,WAAW;AACjB;;AAGJ,cAAM,SAAS,KAAK,OAAO,UAAS;AAGpC,YAAI,CAAC,KAAK,QAAO,GAAI;AACjB;;AAGJ,cAAM,gBAAgB,KAAK,aAAa;AAExC,aAAK,yBAAyB,gBAAgB,IAAI;AAGlD,eAAO,aAAa,KAAK,YAAY;AACrC,eAAO,SAAS,KAAK;AAGrB,sBAAc,WAAW,kBAAkB,KAAK,OAAO;AACvD,sBAAc,UAAU,iBAAiB,KAAK,QAAS,iBAAgB,CAAE;AAGzE,sBAAc,UAAU,SAAS,KAAK,MAAM,GAAG,KAAK,MAAM,GAAG,KAAK,MAAM,GAAG,KAAK,MAAM,CAAC;AAGvF,sBAAc,WAAW,UAAU,KAAK,MAAM;AAC9C,sBAAc,WAAW,SAAS,KAAK,KAAK;AAG5C,eAAO,YAAY,KAAK,gBAAgB,KAAK,cAAc,aAAa;AAGxE,YAAI,CAAC,KAAK,WAAW;AACjB,iBAAO,aAAa,KAAK,iBAAiB;AAC1C,iBAAO,iBAAiB,SAAS,kBAAkB,GAAG,CAAC;AACvD,iBAAO,aAAa,CAAA;eACjB;AACH,iBAAO,iBAAiB,SAAS,kBAAkB,GAAG,CAAC;;AAG3D,aAAK,wBAAwB,gBAAgB,IAAI;MACrD;;;;MAKO,UAAO;AACV,cAAM,eAAe,KAAK,eAAe,aAAa,YAAY;AAClE,YAAI,cAAc;AACd,uBAAa,QAAO;AACpB,eAAK,eAAe,aAAa,YAAY,IAAI;;AAGrD,YAAI,KAAK,cAAc;AACnB,eAAK,OAAO,UAAS,EAAG,eAAe,KAAK,YAAY;AACxD,eAAK,eAAe;;AAGxB,YAAI,KAAK,SAAS;AACd,eAAK,QAAQ,QAAO;AACpB,eAAK,UAAU;;AAInB,aAAK,uBAAuB,CAAA;AAG5B,cAAM,QAAQ,KAAK,OAAO,OAAO,QAAQ,IAAI;AAC7C,aAAK,OAAO,OAAO,OAAO,OAAO,CAAC;AAGlC,aAAK,oBAAoB,gBAAgB,IAAI;AAE7C,aAAK,oBAAoB,MAAK;AAC9B,aAAK,wBAAwB,MAAK;AAClC,aAAK,yBAAyB,MAAK;MACvC;;;;",
  "names": ["name", "name", "shader", "name"]
}
